#!/usr/bin/env python3

import subprocess
import re
from os import path
from collections import defaultdict
from pathlib import Path

# Path to the vmlinux file with debug symbols
VMLINUX_PATH = "$HOME/linux/vmlinux"
# Path to the kernel source code tree
KERNEL_SRC_PATH = "$HOME/linux/"
# Log file generated by vock
COVERAGE_LOG = "coverage.log"
# Number of context lines to show around a covered line
CONTEXT_LINES = 8

# ANSI escape codes for colored output
COLOR = {
    "GREEN": '\033[92m', "RESET": '\033[0m', "YELLOW_BOLD": '\033[1;33m',
    "CYAN": '\033[96m', "YELLOW": '\033[93m', "RED": '\033[91m'
}

def print_code_with_context(file_path, covered_lines):
    """Reads a source file and prints covered lines with surrounding context."""
    try:
        with open(file_path, 'r', errors='ignore') as f:
            all_lines = f.readlines()
    except FileNotFoundError:
        # This case should be handled by the main logic, but as a safeguard:
        return False

    lines_to_print = set()
    for line_num in covered_lines:
        start = max(1, line_num - CONTEXT_LINES)
        end = min(len(all_lines), line_num + CONTEXT_LINES)
        for i in range(start, end + 1):
            lines_to_print.add(i)

    sorted_lines = sorted(list(lines_to_print))
    if not sorted_lines: return True

    last_line = -1
    for line_num in sorted_lines:
        if line_num != last_line + 1:
            print(f"{COLOR['CYAN']}   ...{COLOR['RESET']}")

        line_content = all_lines[line_num - 1].rstrip()
        
        if line_num in covered_lines:
            print(f"{COLOR['GREEN']}{line_num:5d} > {line_content}{COLOR['RESET']}")
        else:
            print(f"{line_num:5d} | {line_content}")
        last_line = line_num
    print(f"{COLOR['CYAN']}   ...{COLOR['RESET']}")
    return True


def main():
    print(" VOCK Coverage Reporter ".center(80, "="))

    # 1. Read addresses from log file
    coverage_log_path = Path(COVERAGE_LOG)
    if not coverage_log_path.is_file():
        print(f"{COLOR['RED']}[Error]{COLOR['RESET']} Coverage file '{COVERAGE_LOG}' not found.")
        return
        
    with coverage_log_path.open('r') as f:
        addresses = set(line.strip() for line in f if line.strip())

    if not addresses:
        print("No coverage data collected.")
        return
        
    print(f"Read {len(addresses)} unique PC addresses from '{COVERAGE_LOG}'.")

    # 2. Use addr2line in batch mode for efficiency
    print("Translating addresses using addr2line...")
    addr_input = "\n".join(addresses)
    addr2line_cmd = ["addr2line", "-e", VMLINUX_PATH]
    
    proc = subprocess.run(
        addr2line_cmd, input=addr_input, text=True, capture_output=True, check=False
    )

    if proc.returncode != 0:
        print(f"{COLOR['RED']}[Error]{COLOR['RESET']} addr2line failed. Is VMLINUX_PATH correct?")
        print(proc.stderr)
        return

    # 3. Parse addr2line output and aggregate data
    coverage_by_file = defaultdict(set)
    # The output corresponds line-by-line to the input addresses
    output_lines = proc.stdout.strip().split('\n')

    for line_info in output_lines:
        match = re.match(r'(.+):(\d+)', line_info)
        if match:
            file_path_str, line_num_str = match.groups()
            if file_path_str == '??': continue
            
            relative_path = path.relpath(file_path_str, KERNEL_SRC_PATH)
            coverage_by_file[relative_path].add(int(line_num_str))

    # 4. Generate Report
    print("\n" + " Coverage Report ".center(80, "-"))
    
    kernel_src_path = Path(KERNEL_SRC_PATH)
    source_code_available = kernel_src_path.is_dir()
    if not source_code_available:
        print(f"{COLOR['YELLOW']}‚ö†Ô∏è  [Warning]{COLOR['RESET']} Kernel source directory not found at '{KERNEL_SRC_PATH}'.")
        print("Displaying file and line numbers only.\n")

    for file_path_str, lines in sorted(coverage_by_file.items()):
        full_path = kernel_src_path / file_path_str
        
        print(f"üìÑ {COLOR['YELLOW_BOLD']}{file_path_str}{COLOR['RESET']} ({len(lines)} lines covered)")

        if source_code_available and full_path.is_file():
            print_code_with_context(full_path, lines)
        else:
            # Fallback view: just print the line numbers
            sorted_lines = sorted(list(lines))
            for i in range(0, len(sorted_lines), 10):
                print("   " + " ".join(map(str, sorted_lines[i:i+10])))

if __name__ == "__main__":
    main()

